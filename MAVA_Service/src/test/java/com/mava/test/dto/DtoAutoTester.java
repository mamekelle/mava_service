package com.mava.test.dto;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.web.WebAppConfiguration;

import com.mava.util.WebConfig;

@WebAppConfiguration
@ContextConfiguration(classes = { WebConfig.class })
@TestPropertySource("classpath:application-test.properties")
public class DtoAutoTester {

	public static Object getValueByType(Class<?> cls) throws InstantiationException, IllegalAccessException {
		if (cls.isArray()) {
			return Array.newInstance(cls.getComponentType(), 1);
		}
		switch (cls.getName()) {
		case "int":
		case "short":
		case "double":
		case "float":
		case "java.lang.Integer":
		case "java.lang.Number":
		case "java.lang.Double":
		case "java.lang.Short":
		case "java.lang.Float":
		case "java.lang.BigDecimal":
		case "java.lang.BigInteger":
			return 123;
		case "long":
		case "java.lang.Long":
			return 123L;
			
		case "java.sql.Timestamp":
			return Timestamp.valueOf("2016-12-31 00:00:00.77");

		case "bool":
		case "java.lang.Boolean":
			return true;

		case "char":
		case "java.lang.Character":
			return 't';

		case "java.lang.String":
			return "test-string";

		case "java.util.List":
			return new ArrayList<>();
		case "javax.xml.bind.JAXBElement":
			return null;
		default:
			return cls.newInstance();
		}
	}

	@SuppressWarnings("rawtypes")
	public static Object testClassMethods(Class<?> cls, String... exceptions)
			throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
		Object obj = cls.newInstance();
		Field[] fields = cls.getDeclaredFields();
		List<String> exList = Arrays.asList(exceptions);
		for (Field field : fields) {
			try {
				if (field.isSynthetic()) {
					continue;
				}
				if (exList.stream().filter(ex -> ex.equals(field.getName())).count() > 0) {
					continue;
				}
				PropertyDescriptor value = (!cls.getName().contains("Output")
						&& cls.getPackage().getName().contains("soap.generated"))
								? new PropertyDescriptor(field.getName(), cls, "get" + field.getName().toUpperCase(),
										"set" + field.getName().toUpperCase())
								: new PropertyDescriptor(field.getName(), cls);

				Object expectedValue = DtoAutoTester.getValueByType(field.getType());
				value.getWriteMethod().invoke(obj, expectedValue);
				Object invoke = value.getReadMethod().invoke(obj, null);
//				if (field.getType().isPrimitive()) {
//					assertTrue(invoke == expectedValue);
//				} else {
				assertTrue((invoke == null && expectedValue == null) || invoke.equals(expectedValue));
//				}
				assertNotNull(obj.toString());
				assertNotNull(obj.hashCode());
				assertNotNull(obj.equals(obj));
			} catch (IntrospectionException | InstantiationException e) {
				System.out.println(e);
				// Getter and/or Setter does not exists.
			}
		}
		Class[] subclasses = cls.getClasses();
		for (int i = 0; i < subclasses.length; i++) {
			DtoAutoTester.testClassMethods(subclasses[i]);
		}

		// SOAP Factory!
		if (cls.getName().contains("Factory") || cls.getPackage().getName().contains("autogenerated")) {
			Method[] methods = cls.getDeclaredMethods();
			for (Method method : methods) {
				try {
					if (method.getParameterCount() == 0) {
						method.invoke(obj);
					} else {
						method.invoke(obj, new Object[]{ null });
					}
				} catch (Exception e) {
					// Nothing.
					System.out.println(e);
				}
			}
		}
		return obj;
	}

}
